Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/HardwareSimpleBot.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.simpleBotCode;\n\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.util.ElapsedTime;\nimport com.qualcomm.robotcore.util.Range;\n\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\nimport org.firstinspires.ftc.teamcode.simpleBotCode.autos.remoteAuto;\n\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.ACCELERATION_INCREMENT;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.FLYWHEEL_SPEED;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.INTAKE_SPEED;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.NUMBER_OF_DRIVE_MOTORS;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.WHITE_ALPHA_THRESHOLD;\n\npublic class HardwareSimpleBot {\n    /* Public OpMode members. */\n    //motors\n    public DcMotor FR = null;\n    public DcMotor FL = null;\n    public DcMotor BR = null;\n    public DcMotor BL = null;\n    public DcMotor flywheel = null;\n    public DcMotor intake = null;\n    //servos\n    public Servo lifter = null;\n    public Servo shooter = null;\n    //imu:\n    public BNO055IMU imu;\n\n    Orientation angles;\n    Orientation lastAngles = new Orientation();\n    public double globalAngle, power = .30, correction;\n\n    //Leds: for future use\n//    RevBlinkinLedDriver blinkinLedDriver ;\n//    RevBlinkinLedDriver.BlinkinPattern pattern ;\n\n\n    /* local OpMode members. */\n    HardwareMap hwMap = null;\n    private final ElapsedTime period = new ElapsedTime();\n    LinearOpMode opMode;\n\n\n    /* Initialize standard Hardware interfaces */\n    public void init(HardwareMap ahwMap, LinearOpMode opMode) {\n        this.opMode = opMode;\n        //IMU Setup:\n        // Set up the parameters with which we will use our IMU. Note that integration\n        // algorithm here just reports accelerations to the logcat log; it doesn't actually\n        // provide positional information.\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n        parameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n        //parameters.calibrationDataFile = \"BNO055IMUCalibration.json\"; // see the calibration sample opmode\n        parameters.loggingEnabled = true;\n        parameters.loggingTag = \"IMU\";\n        parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();\n\n\n        // Save reference to Hardware map\n        hwMap = ahwMap;\n\n        // Define and Initialize Motors\n        FR = hwMap.get(DcMotor.class, \"FR\");\n        FL = hwMap.get(DcMotor.class, \"FL\");\n        BR = hwMap.get(DcMotor.class, \"BR\");\n        BL = hwMap.get(DcMotor.class, \"BL\");\n        flywheel = hwMap.get(DcMotor.class, \"flywheel\");\n        intake = hwMap.get(DcMotor.class, \"intake\");\n\n        // Define and Initialize Servos\n        shooter = hwMap.get(Servo.class, \"shooter\");\n        lifter = hwMap.get(Servo.class, \"lifter\");\n\n        //Define and Initalize BNO055IMU\n        imu = hwMap.get(BNO055IMU.class, \"imu\");\n        imu.initialize(parameters);\n\n        // Define and Initialize LED's\n        // blinkinLedDriver = hwMap.get(RevBlinkinLedDriver.class, \"blinkin\");\n\n        // Set motor directions\n        FR.setDirection(DcMotor.Direction.REVERSE);\n        FL.setDirection(DcMotor.Direction.FORWARD);\n        BR.setDirection(DcMotor.Direction.REVERSE);\n        BL.setDirection(DcMotor.Direction.FORWARD);\n        flywheel.setDirection(DcMotor.Direction.FORWARD);\n        intake.setDirection(DcMotorSimple.Direction.REVERSE);\n\n        // Set rb behavior when power is zero (BRAKE = brake, FLOAT = no brake)\n        FR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        FL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        BR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        BL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        flywheel.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT); //no need to brake flywheel\n        intake.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n\n        // Set all motors to zero power for initialization\n        FR.setPower(0);\n        FL.setPower(0);\n        BR.setPower(0);\n        BL.setPower(0);\n        flywheel.setPower(0);\n        intake.setPower(0);\n\n\n        // Set all motors to run without encoders.\n\n        FR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        FL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        BR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        BL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        flywheel.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        intake.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n\n    }//End init code\n\n    //Driving Functions\n\n    /**\n     * Stops all motors and applies zero power behavior from config (either BRAKE or FLOAT)\n     */\n    public void driveStop() {\n        FR.setPower(0);\n        FL.setPower(0);\n        BR.setPower(0);\n        BL.setPower(0);\n    }\n\n    /**\n     * Sets all wheels to same drive speed.\n     *\n     * @param speed -1 to 1\n     */\n    public void drive(double speed) {\n        FR.setPower(speed);\n        FL.setPower(speed);\n        BR.setPower(speed);\n        BL.setPower(speed);\n    }\n\n    /**\n     * Sets wheels on left and right sides of robot to different speeds\n     *\n     * @param leftPower  Left Motors Speed -1 to 1\n     * @param rightPower Right Motors Speed -1 to 1\n     */\n    public void drive(double leftPower, double rightPower) {\n        FR.setPower(rightPower);\n        FL.setPower(leftPower);\n        BR.setPower(rightPower);\n        BL.setPower(leftPower);\n    }\n\n    /**\n     * Sets each drive motor to individual speeds, used by main mecanum driving function in simpleBotTeleOp.java\n     *\n     * @param frontrightPower Speed -1 to 1\n     * @param frontleftPower  Speed -1 to 1\n     * @param backrightPower  Speed -1 to 1\n     * @param backleftPower   Speed -1 to 1\n     */\n    public void drive(double frontrightPower, double frontleftPower, double backrightPower, double backleftPower) {\n        FR.setPower(frontrightPower);\n        FL.setPower(frontleftPower);\n        BR.setPower(backrightPower);\n        BL.setPower(backleftPower);\n    }\n\n    /**\n     * Strafes Mecanum Drivetrain\n     *\n     * @param speed\n     */\n    public void strafe(double speed) {\n        FR.setPower(speed);\n        FL.setPower(-speed);\n        BR.setPower(-speed);\n        BL.setPower(speed);\n    }\n\n    /**\n     * @param frontMotors Higher values = more right rotation\n     * @param rearMotors  Higher values = more left rotation\n     */\n    public void strafe(double frontMotors, double rearMotors) {\n        FR.setPower(frontMotors);\n        FL.setPower(-frontMotors);\n        BR.setPower(-rearMotors);\n        BL.setPower(rearMotors);\n    }\n\n    /**\n     * Rotates robot using equal speeds for all drive motors\n     *\n     * @param speed + values are left and - values are right\n     */\n    public void turn(double speed) {\n        FR.setPower(-speed);\n        FL.setPower(speed);\n        BR.setPower(-speed);\n        BL.setPower(speed);\n    }\n\n    /**\n     * Drives robot southwest assuming North is tower side of field\n     *\n     * @param FLspeed\n     * @param BRspeed\n     */\n    //This would be NorthEast if front of robot is intake side\n    public void driveSouthWestAuto(double FLspeed, double BRspeed) {\n        FL.setPower(FLspeed);\n        BR.setPower(BRspeed);\n    }\n\n    //IMU Functions:\n\n    /**\n     * Rotate left or right the number of degrees. Does not support turning more than 180 degrees.\n     *\n     * @param degrees Degrees to turn, + is left - is right\n     * @param power   Motor power during turn (should not be negative)\n     */\n    public void rotate(double degrees, double power) throws InterruptedException {\n\n        // restart imu movement tracking.\n        resetAngle();\n\n        // getAngle() returns + when rotating counter clockwise (left) and - when rotating\n        // clockwise (right).\n\n        if (degrees < 0) {   // turn right.\n            power = -power;\n\n        } else if (degrees > 0) {   // turn left.\n            //return; //power = power; dont need to change anything because assuming the power is already positive, that should make the robot turn right when put into the turn function\n        } else return;\n\n        // set power to rotate.\n        turn(power);\n\n        // rotate until turn is completed.\n        if (degrees < 0) {\n            // On right turn we have to get off zero first.\n            while (opMode.opModeIsActive() && getAngle() == 0) {\n            }\n\n            while (opMode.opModeIsActive() && getAngle() > degrees) {\n            }\n        } else {  // left turn.\n            System.out.println(\"Starting Left Turn..?  Starting Angle is: \" + getAngle());\n            while (opMode.opModeIsActive() && getAngle() < degrees) {\n                System.out.println(\"Turning to angle... Angle right now is:\" + getAngle());\n            }\n        }\n        // turn the motors off.\n        driveStop();\n        System.out.println(\"Done rotating\");\n\n        // wait for rotation to stop.\n        Thread.sleep(100);\n\n        // reset angle tracking on new heading.\n        resetAngle();\n    }\n\n    /**\n     * Rotates to a global heading using IMU\n     * @param degrees\n     * @param power\n     * @throws InterruptedException\n     */\n    public void rotateToGlobalAngle(int degrees, double power) throws InterruptedException {\n\n        // restart imu movement tracking.\n        Orientation currentAngle = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n\n        globalAngle = currentAngle.firstAngle;\n\n        // getAngle() returns + when rotating counter clockwise (left) and - when rotating\n        // clockwise (right).\n\n        if (degrees < 0) {   // turn right.\n            power = -power;\n\n        } else if (degrees > 0) {   // turn left.\n            return;//power = power; dont need to change anything because assuming the power is already positive, that should make the robot turn right when put into the turn function\n        } else return;\n\n        // set power to rotate.\n        turn(power);\n\n        // rotate until turn is completed.\n        if (degrees < 0) {\n            // On right turn we have to get off zero first.\n            while (opMode.opModeIsActive() && getAngle() == 0) {\n            }\n\n            while (opMode.opModeIsActive() && getAngle() > degrees) {\n            }\n        } else    // left turn.\n            while (opMode.opModeIsActive() && getAngle() < degrees) {\n            }\n\n        // turn the motors off.\n        driveStop();\n\n        // wait for rotation to stop.\n        Thread.sleep(100);\n\n        // reset angle tracking on new heading.\n        resetAngle();\n\n\n//        //Old Code:\n//        int currentAngle = (int) getGlobalAngle(); //Get current angle to determine which direction to rotate towards\n//        System.out.println(\"Current Raw Angle: \" + currentAngle);\n//        //Convert target angle from (-180 -- 180) range to (0 -- 360)\n//        int convertedTargetAngle; //IMPORTANT: You only need to use this if you are capturing an angle from the IMU in the -180 to 180 format, otherwise make sure this is off if you are trying to input your own angle. TODO: Double check this for acutal matches\n//        if (targetAngle > 0) {\n//            convertedTargetAngle = targetAngle;\n//        } else if (targetAngle < 0) {\n//            convertedTargetAngle = 180 + Math.abs(targetAngle);\n//        } else {\n//            convertedTargetAngle = targetAngle;\n//        }\n//        System.out.println(\"Converted Target Angle: \" + convertedTargetAngle);\n//        //Convert current angle from (-180 -- 180) range to (0 -- 360)\n//        int convertedCurrentAngle;\n//        if (currentAngle > 0) {\n//            convertedCurrentAngle = currentAngle;\n//        } else if (currentAngle < 0) {\n//            convertedCurrentAngle = 180 + Math.abs(currentAngle);\n//        } else {\n//            convertedCurrentAngle = currentAngle;\n//        }\n//        System.out.println(\"Converted Current Angle: \" + convertedCurrentAngle);\n//        //Calculate which way to rotate:\n//        //TARGET ANGLE = 0 DEGREES\n//        //CURRENT ANGLE = idk 90 DEGREES\n//        //SHOULD TURN RIGHT?\n//\n//        //TARGET ANGLE = 0 DEGREES\n//        //CURRENT ANGLE = 270 DEGREES\n//        //SHOULD TURN LEFT\n//\n//        //TARGET ANGLE = 270 DEGREES\n//        //CURRENT ANGLE = 45 DEGREES\n//        //SHOULD TURN RIGHT\n//\n//        int diff = Math.abs(convertedTargetAngle - convertedCurrentAngle);\n////        if (diff < 0) {\n////            diff += 360;\n////        }\n//\n//\n//        if (diff > 180) {\n//            System.out.println(\"Starting Turning Right...\");\n//            InitialPower = -InitialPower; //turn right\n//\n//        } else {\n//            System.out.println(\"Starting Turning Left...\"); //TODO: Delete all of these before competition\n//\n//        }\n//\n//\n//        turn(InitialPower);\n//\n//        // rotate until turn is completed.\n//        if (diff < 180) {\n//            // On right turn we have to get off zero first.\n////            while (opMode.opModeIsActive() && getGlobalAngle() == 0) {\n////            }\n//\n//            //TODO: Tried to add deceleration here but idk why it's not working....\n//            while (opMode.opModeIsActive() && getGlobalAngle() > 22.5 + targetAngle) {\n//            }\n//            driveStop();\n//            turn(.25);\n//            while (opMode.opModeIsActive() && getGlobalAngle() > 8 + targetAngle) {\n//            }\n//            driveStop();\n//            turn(.10);\n//            while (opMode.opModeIsActive() && getGlobalAngle() > targetAngle) {\n//            }\n//\n//        } else if (diff > 180) {   // left turn.\n//            while (opMode.opModeIsActive() && getGlobalAngle() < targetAngle - 22.5) {\n//            }\n//            turn(-.25);\n//            while (opMode.opModeIsActive() && getGlobalAngle() < targetAngle - 8) {\n//            }\n//            turn(.10);\n//            while (opMode.opModeIsActive() && getGlobalAngle() < targetAngle - 8) {\n//            }\n//\n//        }\n//\n//\n//        // turn the motors off.\n//        driveStop();\n//        System.out.println(\"Turn Completed!\");\n//\n//        // wait for rotation to stop.\n//        Thread.sleep(100);\n\n    }\n\n    /**\n     * Resets the cumulative angle tracking to zero.\n     */\n    private void resetAngle() {\n        lastAngles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n\n        globalAngle = 0;\n    }\n\n    /**\n     * Get current cumulative angle rotation from last reset.\n     *\n     * @return Angle in degrees. + = left, - = right.\n     */\n    public double getAngle() {\n        // We experimentally determined the Z axis is the axis we want to use for heading angle.\n        // We have to process the angle because the imu works in euler angles so the Z axis is\n        // returned as 0 to +180 or 0 to -180 rolling back to -179 or +179 when rotation passes\n        // 180 degrees. We detect this transition and track the total cumulative angle of rotation.\n\n        Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n\n        double deltaAngle = angles.firstAngle - lastAngles.firstAngle;\n\n        if (deltaAngle < -180)\n            deltaAngle += 360;\n        else if (deltaAngle > 180)\n            deltaAngle -= 360;\n\n        globalAngle += deltaAngle;\n\n        lastAngles = angles;\n\n        return globalAngle;\n    }\n\n    /**\n     * Get current heading relative to intialization angle (i think)\n     *\n     * @return Current heading / angle from -180 to 180\n     */\n    public double getGlobalAngle() {\n\n        Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n        return angles.firstAngle;\n    }\n\n    //Encoder Drive Functions:\n\n    /**\n     * Drives forward using 1 encoder\n     *\n     * @param positionChange This should be positive or negative based on direction\n     * @param motor          rb.FL\n     * @param power          Always positive, direction controlled by positionChange\n     */\n    public void driveForwardByEncoder(int positionChange, DcMotor motor, double power) throws InterruptedException {\n        power = Math.abs(power);\n\n        int oldPosition = motor.getCurrentPosition();\n        int targetPosition = oldPosition + positionChange;\n        double currentPower = 0.2; //Always start at 0.2 power\n\n        if (positionChange > 0) {\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() < targetPosition * .75) {\n\n                if (currentPower >= power) {\n                    currentPower = power;\n                } else {\n                    currentPower = currentPower + ACCELERATION_INCREMENT;\n                    Thread.sleep(3);\n                }\n                drive(currentPower);\n            }\n            //deceleration:\n\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() < targetPosition) {\n\n                drive(Range.clip(Math.abs(motor.getCurrentPosition() - targetPosition) / motor.getCurrentPosition() + oldPosition, .1, 1));\n\n            }\n\n            driveStop();\n        } else if (positionChange < 0) {\n            drive(-power);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() > targetPosition) {\n                Thread.yield();\n            }\n            driveStop();\n        }\n\n    }\n\n    /**\n     * Drives forward using encoders and IMU to maintain heading\n     *\n     * @param positionChange This should be positive or negative based on direction\n     * @param motor          rb.FL, but irrelevent for this because we use all motor encoders now\n     * @param power          Always positive 0-1, direction controlled by positionChange\n     * @param correctionGain Controls how much correction is applied to maintain heading, values below 0.10 work well most of the time.\n     */\n    public void driveForwardByEncoderAndIMU(int positionChange, DcMotor motor, double power, double correctionGain) {\n//For Reference:\n//        FR.setDirection(DcMotor.Direction.REVERSE);\n//        FL.setDirection(DcMotor.Direction.FORWARD);\n//        BR.setDirection(DcMotor.Direction.REVERSE);\n//        BL.setDirection(DcMotor.Direction.FORWARD);\n\n        //Make sure that power is positive\n        power = Math.abs(power);\n        //Store Initial Positions for all Motors\n        int FLoldPosition = FL.getCurrentPosition();\n        int FRoldPosition = FR.getCurrentPosition();\n        int BLoldPosition = BL.getCurrentPosition();\n        int BRoldPosition = BR.getCurrentPosition();\n\n        int FLtargetPosition = FLoldPosition + positionChange; //example: old = 500, pos change = 200, target = 700\n        int FRtargetPosition = FRoldPosition - positionChange; // example: old = -500, pos change = 200, target = -700\n        int BLtargetPosition = BLoldPosition + positionChange;\n        int BRtargetPosition = BRoldPosition - positionChange;\n\n        int FLdistanceToZero = Math.abs(FLtargetPosition - FLoldPosition);\n        int FRdistanceToZero = Math.abs(FRtargetPosition - FRoldPosition);\n        int BLdistanceToZero = Math.abs(BLtargetPosition - BLoldPosition);\n        int BRdistanceToZero = Math.abs(BRtargetPosition - BRoldPosition);\n\n        double averageDistancetoTargetPosition = (FLdistanceToZero + FRdistanceToZero + BLdistanceToZero + BRdistanceToZero) / NUMBER_OF_DRIVE_MOTORS; //Goes from positive number (ex 500 --> 0)\n\n        if (positionChange > 0) {\n            double currentPower = 0.2; //Always start at 0.2 power\n            drive(currentPower);\n            while (opMode.opModeIsActive() && averageDistancetoTargetPosition > 0.2 * Math.abs(positionChange)) { //run normally until 80% of distance traveled\n\n                if (currentPower >= power) {\n                    currentPower = power;\n                } else {\n                    currentPower += ACCELERATION_INCREMENT;\n\n                }\n                // Use IMU to drive in a straight line.\n                correction = checkCorrection(correctionGain);\n                drive((currentPower + correction), (currentPower - correction));\n\n                //Update Current Distance to 0 for each motor with current encoder readings\n                FLdistanceToZero = Math.abs(FLtargetPosition - FL.getCurrentPosition());\n                FRdistanceToZero = Math.abs(FRtargetPosition - FR.getCurrentPosition());\n                BLdistanceToZero = Math.abs(BLtargetPosition - BL.getCurrentPosition());\n                BRdistanceToZero = Math.abs(BRtargetPosition - BR.getCurrentPosition());\n                //and average it\n                averageDistancetoTargetPosition = (FLdistanceToZero + FRdistanceToZero + BLdistanceToZero + BRdistanceToZero) / NUMBER_OF_DRIVE_MOTORS;\n\n            }\n\n            while (opMode.opModeIsActive() && averageDistancetoTargetPosition > 0) {\n                //TODO: Rewrite deceleration stuff, right now it just drives at 50% speed for the last 20% of the route, not the best way to do it but it works\n//                double decelerationSpeed = (Range.clip(Math.abs(motor.getCurrentPosition() - FLtargetPosition) / motor.getCurrentPosition() + FLoldPosition, .1, power));\n//                System.out.println(decelerationSpeed);\n\n                correction = checkCorrection(correctionGain);\n                drive((currentPower / 2 + correction), (currentPower / 2 - correction));\n                //Update Current Distance to 0 for each motor with current encoder readings\n                FLdistanceToZero = Math.abs(FLtargetPosition - FL.getCurrentPosition());\n                FRdistanceToZero = Math.abs(FRtargetPosition - FR.getCurrentPosition());\n                BLdistanceToZero = Math.abs(BLtargetPosition - BL.getCurrentPosition());\n                BRdistanceToZero = Math.abs(BRtargetPosition - BR.getCurrentPosition());\n                //and average it\n                averageDistancetoTargetPosition = (FLdistanceToZero + FRdistanceToZero + BLdistanceToZero + BRdistanceToZero) / 4;\n            }\n\n            driveStop();\n\n        } else if (positionChange < 0) {\n            double currentPower = -0.2; //Always start at 0.2 power\n            drive(currentPower);\n            while (opMode.opModeIsActive() && averageDistancetoTargetPosition > 0.2 * Math.abs(positionChange)) {\n\n                if (currentPower >= -power) {\n                    currentPower = -power;\n                } else {\n                    currentPower -= ACCELERATION_INCREMENT;\n\n                }\n                // Use IMU to drive in a straight line.\n                correction = checkCorrection(correctionGain);\n                drive((currentPower + correction), (currentPower - correction));\n\n                FLdistanceToZero = Math.abs(FLtargetPosition - FL.getCurrentPosition());\n                FRdistanceToZero = Math.abs(FRtargetPosition - FR.getCurrentPosition());\n                BLdistanceToZero = Math.abs(BLtargetPosition - BL.getCurrentPosition());\n                BRdistanceToZero = Math.abs(BRtargetPosition - BR.getCurrentPosition());\n                //and average it\n                averageDistancetoTargetPosition = (FLdistanceToZero + FRdistanceToZero + BLdistanceToZero + BRdistanceToZero) / 4;\n            }\n\n            while (opMode.opModeIsActive() && averageDistancetoTargetPosition > 0) {\n//                double decelerationSpeed = (Range.clip(Math.abs(motor.getCurrentPosition() - FLtargetPosition) / motor.getCurrentPosition() + FLoldPosition, power, -.1));\n//                System.out.println(decelerationSpeed);\n\n                correction = checkCorrection(correctionGain);\n                drive((currentPower / 2 + correction), (currentPower / 2 - correction));\n\n                //Update Current Distance to 0 for each motor with current encoder readings\n                FLdistanceToZero = Math.abs(FLtargetPosition - FL.getCurrentPosition());\n                FRdistanceToZero = Math.abs(FRtargetPosition - FR.getCurrentPosition());\n                BLdistanceToZero = Math.abs(BLtargetPosition - BL.getCurrentPosition());\n                BRdistanceToZero = Math.abs(BRtargetPosition - BR.getCurrentPosition());\n                //and average it\n                averageDistancetoTargetPosition = (FLdistanceToZero + FRdistanceToZero + BLdistanceToZero + BRdistanceToZero) / 4;\n\n            }\n\n            driveStop();\n        }\n\n    }\n\n    /**\n     * Drives forward with IMU to maintain heading to line on field\n     *\n     * @param power     NEGATIVE OR POSITIVE POWER CONTROLS DIRECTION\n     * @param lineColor Linecolor to detect (white, blue)\n     */\n    public void driveForwardByIMUtoLine(double power, String lineColor) {\n\n\n        if (lineColor.equals(\"white\")) {\n            if (power > 0) {\n                drive(power);\n                while (opMode.opModeIsActive() && remoteAuto.groundColorSensor.alpha() < WHITE_ALPHA_THRESHOLD) {\n\n                    int currentAngle; //Stores heading at beginning of function\n                    // Use IMU to drive in a straight line.\n                    correction = checkCorrection(.1);\n                    drive((power + correction), (power - correction));\n                    Thread.yield();\n                }\n\n                driveStop();\n            } else if (power < 0) {\n                drive(-power);\n                while (opMode.opModeIsActive() && remoteAuto.groundColorSensor.alpha() < WHITE_ALPHA_THRESHOLD) {\n                    // Use IMU to drive in a straight line.\n                    correction = checkCorrection(.1);\n                    drive((power - correction), (power + correction));\n                    Thread.yield();\n                }\n                driveStop();\n            }\n        }\n\n\n    }\n\n\n    /**\n     * Checks how much of a correction to make\n     *\n     * @return Power adjustment, + is adjust left - is adjust right.\n     */\n    private double checkCorrection(Double correctionGain) {\n        // gain value determines how sensitive the correction is to direction changes\n        //default = .10\n        double correction, angle, gain = correctionGain;\n\n        angle = getAngle();\n\n        if (angle == 0)\n            correction = 0;             // no adjustment.\n        else\n            correction = -angle;        // reverse sign of angle for correction.\n\n        correction = correction * gain;\n\n        return correction;\n    }\n\n    /**\n     * Drives southwest, assuming tower goals are North and robot shooter is facing towards tower goals.\n     *\n     * @param positionChange Positive or negative value controls direction, Negative Values move north east\n     * @param motor          RB.FL\n     * @param power          Positive value, 0-1\n     * @param correctionGain\n     */\n    public void autoDriveSouthWestWithEncoderAndIMU(int positionChange, DcMotor motor, double power, double correctionGain) {\n        power = Math.abs(power);\n\n        int oldPosition = motor.getCurrentPosition();\n        int targetPosition = oldPosition - positionChange;\n        double currentPower = 0.2; //Always start at 0.2 power\n\n        if (positionChange > 0) {\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() > targetPosition) {\n\n                // Use IMU to drive in a straight line.\n                correction = checkCorrection(correctionGain);\n                driveSouthWestAuto(-(power - correction), -(power + correction));\n                Thread.yield();\n            }\n\n            driveStop();\n        } else if (positionChange < 0) {\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() > targetPosition) {\n                // Use IMU to drive in a straight line.\n                correction = checkCorrection(correctionGain);\n                driveSouthWestAuto((power + correction), (power - correction));\n                Thread.yield();\n            }\n            driveStop();\n        }\n\n    }\n\n    /**\n     * Drives southwest, assuming tower goals are North and robot shooter is facing towards tower goals.\n     *\n     * @param positionChange Positive or negative value controls direction, Negative Values move north east\n     * @param motor          RB.FL\n     * @param power          Positive value, 0-1\n     * @param correctionGain\n     */\n\n    //TODO: Add More Encoders so we can actually use this\n    public void autoDriveNorthEastWithEncoderAndIMU(int positionChange, DcMotor motor, double power, double correctionGain) {\n        power = Math.abs(power);\n\n        int oldPosition = motor.getCurrentPosition();\n        int targetPosition = oldPosition - positionChange;\n\n        if (positionChange > 0) {\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() > targetPosition) {\n\n                // Use IMU to drive in a straight line.\n                correction = checkCorrection(correctionGain);\n                driveSouthWestAuto(-(power - correction), -(power + correction));\n                Thread.yield();\n            }\n\n            driveStop();\n        } else if (positionChange < 0) {\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() > targetPosition) {\n                // Use IMU to drive in a straight line.\n                correction = checkCorrection(correctionGain);\n                driveSouthWestAuto((power - correction), (power + correction));\n                Thread.yield();\n            }\n            driveStop();\n        }\n\n    }\n\n\n    public void strafeRightByEncoder(int positionChange, DcMotor motor, double power) {\n        power = Math.abs(power);\n        int oldPosition = motor.getCurrentPosition();\n        int targetPosition = oldPosition + positionChange;\n\n        if (positionChange > 0) {\n            strafe(power);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() < targetPosition) {\n                Thread.yield();\n            }\n            driveStop();\n        } else if (positionChange < 0) {\n            strafe(-power);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() > targetPosition) {\n                Thread.yield();\n            }\n            driveStop();\n        }\n\n    }\n\n    /**\n     * Strafes to the right using IMU to maintain angle and encoders for position\n     *\n     * @param positionChange Use negative to strafe to the left\n     * @param motor          rb.FL for example\n     * @param power          0 - 1, positive values only\n     */\n\n    public void strafeRightByEncoderAndIMU(int positionChange, DcMotor motor, double power, double correctionGain) {\n\n        power = Math.abs(power);\n\n        int oldPosition = motor.getCurrentPosition();\n        int targetPosition = oldPosition - positionChange;\n\n        //Current pos = 500\n        //pos change = 200\n        //target = 700\n        //new target = 300\n\n        if (positionChange > 0) {\n            double currentPower = 0.2; //Always start at 0.2 power\n            strafe(currentPower);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() > targetPosition) {\n\n                if (currentPower >= power) {\n                    currentPower = power;\n                } else {\n                    currentPower += ACCELERATION_INCREMENT;\n\n                }\n\n                // Use IMU to drive in a straight line.\n                correction = checkCorrection(correctionGain);\n                strafe((currentPower - correction), (currentPower + correction));\n                Thread.yield();\n            }\n            driveStop();\n            System.out.println(\"Ok, done running.\");\n\n\n        } else if (positionChange < 0) {\n            double currentPower = -0.2; //Always start at 0.2 power\n            strafe(currentPower);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() < targetPosition) {\n\n                if (currentPower >= -power) {\n                    currentPower = -power;\n                } else {\n                    currentPower -= ACCELERATION_INCREMENT;\n\n                }\n\n                // Use IMU to drive in a straight line.\n                correction = checkCorrection(correctionGain);\n                strafe((currentPower - correction), (currentPower + correction));\n\n                Thread.yield();\n            }\n            driveStop();\n        }\n\n        driveStop();\n\n    }\n\n\n    public void turnClockwiseByEncoder(int positionChange, DcMotor motor, double power) {\n        power = Math.abs(power);\n        int oldPosition = motor.getCurrentPosition();\n        int targetPosition = oldPosition + positionChange;\n\n        if (positionChange > 0) {\n            turn(power);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() < targetPosition) {\n                Thread.yield();\n            }\n            driveStop();\n        } else if (positionChange < 0) {\n            turn(-power);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() > targetPosition) {\n                Thread.yield();\n            }\n            driveStop();\n        }\n    }\n\n    public void driveWithLeftMore(int positionChange, DcMotor motor, double power) {\n        power = Math.abs(power);\n        int oldPosition = motor.getCurrentPosition();\n        int targetPosition = oldPosition + positionChange;\n\n        if (positionChange > 0) {\n            FR.setPower(power);\n            FL.setPower(power);\n            BR.setPower(power);\n            BL.setPower(power);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() < targetPosition) {\n                Thread.yield();\n            }\n\n            driveStop();\n        } else if (positionChange < 0) {\n            FR.setPower(-power * .66);\n            FL.setPower(-power);\n            BR.setPower(-power * .66);\n            BL.setPower(-power);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() > targetPosition) {\n                Thread.yield();\n            }\n            driveStop();\n        }\n\n    }\n\n    public void driveWithRightMore(int positionChange, DcMotor motor, double power) {\n        power = Math.abs(power);\n        int oldPosition = motor.getCurrentPosition();\n        int targetPosition = oldPosition + positionChange;\n\n        if (positionChange > 0) {\n            FR.setPower(power);\n            FL.setPower(power);\n            BR.setPower(power);\n            BL.setPower(power);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() < targetPosition) {\n                Thread.yield();\n            }\n\n            driveStop();\n        } else if (positionChange < 0) {\n            FR.setPower(-power);\n            FL.setPower(-power * .66);\n            BR.setPower(-power);\n            BL.setPower(-power * .66);\n            while (opMode.opModeIsActive() && motor.getCurrentPosition() > targetPosition) {\n                Thread.yield();\n            }\n            driveStop();\n        }\n\n    }\n\n    //MECHANISM FUNCTIONS:\n\n    /**\n     * Moves Servo that pushes rings into flywheel\n     *\n     * @param isOut True = servo goes out, False = idk\n     */\n    public void moveShooter(boolean isOut) {\n        if (isOut) {\n            shooter.setPosition(simpleBotConstants.SHOOTER_OUT);\n        } else {\n            shooter.setPosition(simpleBotConstants.SHOOTER_IN);\n        }\n    }\n\n    /**\n     * Turns flywheel on or off\n     *\n     * @param isOn True = flywheel on, False = flywheel off\n     */\n    public void runFlywheel(boolean isOn) {\n\n        if (isOn) {\n            flywheel.setPower(FLYWHEEL_SPEED);\n        } else {\n            flywheel.setPower(0);\n        }\n    }\n\n    public void setLifter(boolean isUp) {\n        if (isUp) {\n            lifter.setPosition(simpleBotConstants.LIFTER_UP);\n        } else {\n            lifter.setPosition(simpleBotConstants.LIFTER_DOWN);\n        }\n    }\n\n    /**\n     * Turns intake on and off\n     *\n     * @param isOn    True = intake on, False = intake off\n     * @param reverse True = runs in reverse to unstuck rings, False = Runs normally\n     */\n    public void runIntake(boolean isOn, boolean reverse) {\n\n        if (isOn) {\n            if (reverse)\n                intake.setPower(-INTAKE_SPEED);\n            else {\n                intake.setPower(INTAKE_SPEED);\n            }\n        } else {\n            intake.setPower(0);\n        }\n    }\n\n\n//    //OLD ROBOT FUNCTIONS\n\n////    public void ledColorFLashYellow() {\n////        pattern = RevBlinkinLedDriver.BlinkinPattern.STROBE_GOLD;\n////        blinkinLedDriver.setPattern(pattern);\n////    }\n////\n////    public void ledColorGreen() {\n////        pattern = RevBlinkinLedDriver.BlinkinPattern.GREEN;\n////        blinkinLedDriver.setPattern(pattern);\n////    }\n////\n////    public void ledColorOrange() {\n////        pattern = RevBlinkinLedDriver.BlinkinPattern.ORANGE;\n////        blinkinLedDriver.setPattern(pattern);\n////    }\n////\n////    public void flashRed() {\n////        pattern = RevBlinkinLedDriver.BlinkinPattern.STROBE_RED;\n//        blinkinLedDriver.setPattern(pattern);\n//    }\n//\n//    public void ledOff() {\n//        pattern = RevBlinkinLedDriver.BlinkinPattern.BLACK;\n//        blinkinLedDriver.setPattern(pattern);\n//    }\n\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/HardwareSimpleBot.java	(revision 08d6dff14699fde4d0817630ff132e0fc59d60c2)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/HardwareSimpleBot.java	(date 1611026064000)
@@ -537,8 +537,8 @@
         int BLoldPosition = BL.getCurrentPosition();
         int BRoldPosition = BR.getCurrentPosition();
 
-        int FLtargetPosition = FLoldPosition + positionChange; //example: old = 500, pos change = 200, target = 700
-        int FRtargetPosition = FRoldPosition - positionChange; // example: old = -500, pos change = 200, target = -700
+        int FLtargetPosition = FLoldPosition + positionChange; //example: old = 500, pos change = 200, target = 700 OR old = -500 pos change = 200 TARGET = -500
+        int FRtargetPosition = FRoldPosition - positionChange; // example: old = -500, pos change = 200, target = -700 OR old = 500 pos change = idkkkkk
         int BLtargetPosition = BLoldPosition + positionChange;
         int BRtargetPosition = BRoldPosition - positionChange;
 
