Index: FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptI2cAddressChange.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted (subject to the limitations in the disclaimer below) provided that\n * the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this list\n * of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice, this\n * list of conditions and the following disclaimer in the documentation and/or\n * other materials provided with the distribution.\n *\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\n * promote products derived from this software without specific prior written permission.\n *\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.firstinspires.ftc.robotcontroller.external.samples;\n\nimport com.qualcomm.hardware.modernrobotics.ModernRoboticsUsbDeviceInterfaceModule;\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DeviceInterfaceModule;\nimport com.qualcomm.robotcore.hardware.I2cAddr;\nimport com.qualcomm.robotcore.util.RobotLog;\nimport com.qualcomm.robotcore.util.TypeConversion;\n\nimport java.util.concurrent.locks.Lock;\n\n/**\n * An example of a linear op mode that shows how to change the I2C address.\n */\n@TeleOp(name = \"Concept: I2c Address Change\", group = \"Concept\")\n@Disabled\npublic class ConceptI2cAddressChange extends LinearOpMode {\n\n  public static final int ADDRESS_SET_NEW_I2C_ADDRESS = 0x70;\n  // trigger bytes used to change I2C address on ModernRobotics sensors.\n  public static final byte TRIGGER_BYTE_1 = 0x55;\n  public static final byte TRIGGER_BYTE_2 = (byte) 0xaa;\n\n  // Expected bytes from the Modern Robotics IR Seeker V3 memory map\n  public static final byte IR_SEEKER_V3_FIRMWARE_REV = 0x12;\n  public static final byte IR_SEEKER_V3_SENSOR_ID = 0x49;\n  public static final I2cAddr IR_SEEKER_V3_ORIGINAL_ADDRESS = I2cAddr.create8bit(0x38);\n\n  // Expected bytes from the Modern Robotics Color Sensor memory map\n  public static final byte COLOR_SENSOR_FIRMWARE_REV = 0x10;\n  public static final byte COLOR_SENSOR_SENSOR_ID = 0x43;\n  public static final byte COLOR_SENSOR_ORIGINAL_ADDRESS = 0x3C;\n\n  public static final byte MANUFACTURER_CODE = 0x4d;\n  // Currently, this is set to expect the bytes from the IR Seeker.\n  // If you change these values so you're setting \"FIRMWARE_REV\" to\n  // COLOR_SENSOR_FIRMWARE_REV, and \"SENSOR_ID\" to \"COLOR_SENSOR_SENSOR_ID\",\n  // you'll be able to change the I2C address of the ModernRoboticsColorSensor.\n  // If the bytes you're expecting are different than what this op mode finds,\n  // a comparison will be printed out into the logfile.\n  public static final byte FIRMWARE_REV = IR_SEEKER_V3_FIRMWARE_REV;\n  public static final byte SENSOR_ID = IR_SEEKER_V3_SENSOR_ID;\n\n  // These byte values are common with most Modern Robotics sensors.\n  public static final int READ_MODE = 0x80;\n  public static final int ADDRESS_MEMORY_START = 0x0;\n  public static final int TOTAL_MEMORY_LENGTH = 0x0c;\n  public static final int BUFFER_CHANGE_ADDRESS_LENGTH = 0x03;\n\n  // The port where your sensor is connected.\n  int port = 5;\n\n  byte[] readCache;\n  Lock readLock;\n  byte[] writeCache;\n  Lock writeLock;\n\n  I2cAddr currentAddress = IR_SEEKER_V3_ORIGINAL_ADDRESS;\n  // I2c addresses on Modern Robotics devices must be divisible by 2, and between 0x7e and 0x10\n  // Different hardware may have different rules.\n  // Be sure to read the requirements for the hardware you're using!\n  // If you use an invalid address, you may make your device completely unusable.\n  I2cAddr newAddress = I2cAddr.create8bit(0x42);\n\n  DeviceInterfaceModule dim;\n\n  @Override\n  public void runOpMode() {\n\n    // set up the hardware devices we are going to use\n    dim = hardwareMap.get(DeviceInterfaceModule.class, \"dim\");\n\n    readCache = dim.getI2cReadCache(port);\n    readLock = dim.getI2cReadCacheLock(port);\n    writeCache = dim.getI2cWriteCache(port);\n    writeLock = dim.getI2cWriteCacheLock(port);\n\n    // I2c addresses on Modern Robotics devices must be divisible by 2, and between 0x7e and 0x10\n    // Different hardware may have different rules.\n    // Be sure to read the requirements for the hardware you're using!\n    ModernRoboticsUsbDeviceInterfaceModule.throwIfModernRoboticsI2cAddressIsInvalid(newAddress);\n\n    // wait for the start button to be pressed\n    waitForStart();\n\n    performAction(\"read\", port, currentAddress, ADDRESS_MEMORY_START, TOTAL_MEMORY_LENGTH);\n\n    while(!dim.isI2cPortReady(port)) {\n      telemetry.addData(\"I2cAddressChange\", \"waiting for the port to be ready...\");\n      telemetry.update();\n      sleep(1000);\n    }\n\n    // update the local cache\n    dim.readI2cCacheFromController(port);\n\n    // make sure the first bytes are what we think they should be.\n    int count = 0;\n    int[] initialArray = {READ_MODE, currentAddress.get8Bit(), ADDRESS_MEMORY_START, TOTAL_MEMORY_LENGTH, FIRMWARE_REV, MANUFACTURER_CODE, SENSOR_ID};\n    while (!foundExpectedBytes(initialArray, readLock, readCache)) {\n      telemetry.addData(\"I2cAddressChange\", \"Confirming that we're reading the correct bytes...\");\n      telemetry.update();\n      dim.readI2cCacheFromController(port);\n      sleep(1000);\n      count++;\n      // if we go too long with failure, we probably are expecting the wrong bytes.\n      if (count >= 10)  {\n        telemetry.addData(\"I2cAddressChange\", String.format(\"Looping too long with no change, probably have the wrong address. Current address: 8bit=0x%02x\", currentAddress.get8Bit()));\n        hardwareMap.irSeekerSensor.get(String.format(\"Looping too long with no change, probably have the wrong address. Current address: 8bit=0x%02x\", currentAddress.get8Bit()));\n        telemetry.update();\n      }\n    }\n\n    // Enable writes to the correct segment of the memory map.\n    performAction(\"write\", port, currentAddress, ADDRESS_SET_NEW_I2C_ADDRESS, BUFFER_CHANGE_ADDRESS_LENGTH);\n\n    // Write out the trigger bytes, and the new desired address.\n    writeNewAddress();\n    dim.setI2cPortActionFlag(port);\n    dim.writeI2cCacheToController(port);\n\n    telemetry.addData(\"I2cAddressChange\", \"Giving the hardware 60 seconds to make the change...\");\n    telemetry.update();\n\n    // Changing the I2C address takes some time.\n    sleep(60000);\n\n    // Query the new address and see if we can get the bytes we expect.\n    dim.enableI2cReadMode(port, newAddress, ADDRESS_MEMORY_START, TOTAL_MEMORY_LENGTH);\n    dim.setI2cPortActionFlag(port);\n    dim.writeI2cCacheToController(port);\n\n    int[] confirmArray = {READ_MODE, newAddress.get8Bit(), ADDRESS_MEMORY_START, TOTAL_MEMORY_LENGTH, FIRMWARE_REV, MANUFACTURER_CODE, SENSOR_ID};\n    while (!foundExpectedBytes(confirmArray, readLock, readCache)) {\n      telemetry.addData(\"I2cAddressChange\", \"Have not confirmed the changes yet...\");\n      telemetry.update();\n      dim.readI2cCacheFromController(port);\n      sleep(1000);\n    }\n\n    telemetry.addData(\"I2cAddressChange\", \"Successfully changed the I2C address. New address: 8bit=0x%02x\", newAddress.get8Bit());\n    telemetry.update();\n    RobotLog.i(\"Successfully changed the I2C address.\" + String.format(\"New address: 8bit=0x%02x\", newAddress.get8Bit()));\n\n    /**** IMPORTANT NOTE ******/\n    // You need to add a line like this at the top of your op mode\n    // to update the I2cAddress in the driver.\n    //irSeeker.setI2cAddress(newAddress);\n    /***************************/\n\n  }\n\n  private boolean foundExpectedBytes(int[] byteArray, Lock lock, byte[] cache) {\n    try {\n      lock.lock();\n      boolean allMatch = true;\n      StringBuilder s = new StringBuilder(300 * 4);\n      String mismatch = \"\";\n      for (int i = 0; i < byteArray.length; i++) {\n        s.append(String.format(\"expected: %02x, got: %02x \\n\", TypeConversion.unsignedByteToInt( (byte) byteArray[i]), cache[i]));\n        if (TypeConversion.unsignedByteToInt(cache[i]) != TypeConversion.unsignedByteToInt( (byte) byteArray[i])) {\n          mismatch = String.format(\"i: %d, byteArray[i]: %02x, cache[i]: %02x\", i, byteArray[i], cache[i]);\n          allMatch = false;\n        }\n      }\n      RobotLog.e(s.toString() + \"\\n allMatch: \" + allMatch + \", mismatch: \" + mismatch);\n      return allMatch;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n  private void performAction(String actionName, int port, I2cAddr i2cAddress, int memAddress, int memLength) {\n    if (actionName.equalsIgnoreCase(\"read\")) dim.enableI2cReadMode(port, i2cAddress, memAddress, memLength);\n    if (actionName.equalsIgnoreCase(\"write\")) dim.enableI2cWriteMode(port, i2cAddress, memAddress, memLength);\n\n    dim.setI2cPortActionFlag(port);\n    dim.writeI2cCacheToController(port);\n    dim.readI2cCacheFromController(port);\n  }\n\n  private void writeNewAddress() {\n    try {\n      writeLock.lock();\n      writeCache[4] = (byte) newAddress.get8Bit();\n      writeCache[5] = TRIGGER_BYTE_1;\n      writeCache[6] = TRIGGER_BYTE_2;\n    } finally {\n      writeLock.unlock();\n    }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptI2cAddressChange.java	(revision 43a2d64631ed9bab716cd1efb31b9cf993580125)
+++ FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptI2cAddressChange.java	(date 1614087923000)
@@ -1,32 +1,3 @@
-/* Copyright (c) 2017 FIRST. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted (subject to the limitations in the disclaimer below) provided that
- * the following conditions are met:
- *
- * Redistributions of source code must retain the above copyright notice, this list
- * of conditions and the following disclaimer.
- *
- * Redistributions in binary form must reproduce the above copyright notice, this
- * list of conditions and the following disclaimer in the documentation and/or
- * other materials provided with the distribution.
- *
- * Neither the name of FIRST nor the names of its contributors may be used to endorse or
- * promote products derived from this software without specific prior written permission.
- *
- * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
- * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
 package org.firstinspires.ftc.robotcontroller.external.samples;
 
 import com.qualcomm.hardware.modernrobotics.ModernRoboticsUsbDeviceInterfaceModule;
@@ -43,8 +14,9 @@
 /**
  * An example of a linear op mode that shows how to change the I2C address.
  */
+
 @TeleOp(name = "Concept: I2c Address Change", group = "Concept")
-@Disabled
+
 public class ConceptI2cAddressChange extends LinearOpMode {
 
   public static final int ADDRESS_SET_NEW_I2C_ADDRESS = 0x70;
@@ -91,7 +63,7 @@
   // Different hardware may have different rules.
   // Be sure to read the requirements for the hardware you're using!
   // If you use an invalid address, you may make your device completely unusable.
-  I2cAddr newAddress = I2cAddr.create8bit(0x42);
+  I2cAddr newAddress = I2cAddr.create8bit(0x28);
 
   DeviceInterfaceModule dim;
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/simpleBotTeleOp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.simpleBotCode;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.util.ElapsedTime;\nimport com.qualcomm.robotcore.util.Range;\n\nimport org.firstinspires.ftc.robotcore.external.Func;\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n\nimport java.util.Locale;\n\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.BUTTON_DELAY;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.CENTER_TO_TOWER_DISTANCE;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.DEFAULT_ACCELERATION_INCREMENT;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.DRIVE_STICK_THRESHOLD;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.FLYWHEEL_POWERSHOT_SPEED;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.FLYWHEEL_SPEED;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.SHOOTER_DEFAULT_ROTATION;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.SIDE_TO_CENTER_DISTANCE;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.SIDE_WALL_TO_TOWER_DISTANCE;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.TRIGGER_THRESHOLD;\n\n\n@TeleOp(name = \"!QM TeleOP\", group = \"!Primary\")\npublic class simpleBotTeleOp extends LinearOpMode {\n\n    //private final FtcDashboard dashboard = FtcDashboard.getInstance(); //Comment this out when not using dashboard\n    private final HardwareSimpleBot rb = new HardwareSimpleBot();\n    // Declare OpMode members.\n    private final ElapsedTime runtime = new ElapsedTime();\n\n    //Setup variables:\n    private boolean flywheelOn = false;\n    private final boolean shooterOut = false;\n    private boolean intakeOn = false;\n    private boolean intakeIsEjecting = false;\n    private boolean lifterUp = true; //Default is true because needs to start up to stay in 18in\n    private boolean powershotSpeedActive = false;\n\n    // State used for updating telemetry\n    Orientation angles;\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        //telemetry = new MultipleTelemetry(telemetry, dashboard.getTelemetry());\n\n        telemetry.addData(\"Status\", \"Initializing\");\n        telemetry.update();\n\n        telemetry.addData(\"Status\", \"Initializing Hardware...\");\n        telemetry.update();\n        rb.init(hardwareMap, this); //runs init stuff in HardwareSimpleBot.java\n        rb.lifterMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        telemetry.addData(\"Status\", \"Hardware Map Initialized\");\n        telemetry.update();\n\n        telemetry.addData(\"Status\", \"Calibrating IMU...\");\n        telemetry.update();\n        // make sure the imu gyro is calibrated before continuing.\n        //IMPORTANT: The gyro will not calibrate unless the robot is not moving, make sure the robot is still during initialization.\n        while (!isStopRequested() && !rb.imu.isGyroCalibrated()) {\n            sleep(50);\n            idle();\n        }\n\n        telemetry.addData(\"imu calib status: \", rb.imu.getCalibrationStatus().toString());\n\n        composeTelemetry();\n\n        telemetry.addData(\"Status\", \"Initialized, Ready to Start\");\n        telemetry.update();\n        // Wait for the game to start (driver presses PLAY)\n        rb.lifterMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        waitForStart(); //Everything up to here is initialization\n        runtime.reset();\n\n        // run until the end of the match (driver presses STOP)\n        while (opModeIsActive()) {\n\n            drive(); //Drive robot with sticks\n            shooter(); // Triggers servo that pushes rings into flywheel\n            flywheel(); // Turns flywheel on and off\n            intake();//Turns intake on and off\n            intakeEject(); //Runs intake in reverse for emergencies\n            lifter();//Moves lifter up and down\n            powershotSpeed();\n            //captureAngle(); //TESTING ONLY: Captures angle\n            rotateToAngle(); //TESTING ONLY (for now): Rotates\n            rapidRotateLeft(); //TESTING ONLY: Rotates to the left at max speed\n            rapidRotateRight(); //TESTING ONLY: Rotates to the right at max speed\n            volkswagenMode();\n\n\n            telemetry.update(); //for imu display\n\n\n            /* CONTROLS (for xbox 360 controller)\n             * Driver: (Start + A)\n             * Left Stick - Movement\n             * Right Stick - Rotation\n             * Left Bumper - Intake\n             * Right Bumper - Flywheel on/off\n             * Right Trigger - Shoot servo (only works if flywheel is on)\n             * Left Trigger - TESTING ONLY: Aligns robot to goal\n             * X - Wobble Goal Lifter\n             * Right Stick Button - Rotate -8.6 degrees to shoot straight\n             * Left Stick Button - Intake Eject for Emergencies\n             * D-Pad Down - Slows down flywheel for powershots\n             * D-Pad Left - Rapid Rotate Left\n             * D-Pad Right - Rapid Rotate Right\n             * D-pad Left + Share Button - Volkswagen Mode (do not use)\n             * Gunner: (Start + B) //TODO: Add gunner controls\n             *\n             * */\n        }\n    }\n\n\n    /**\n     * Main mecanum movement function\n     */\n    private void drive() {\n        //Front of robot is  intake side rn\n        //Init variables\n        double frontLeftPower;\n        double frontRightPower;\n        double rearLeftPower;\n        double rearRightPower;\n\n\n        double leftY = gamepad1.left_stick_y;\n        double leftX = gamepad1.left_stick_x;\n        double rightX = gamepad1.right_stick_x;\n\n//        pattern = RevBlinkinLedDriver.BlinkinPattern.ORANGE;\n//        blinkinLedDriver.setPattern(pattern);\n        //DRIVE_STICK_THRESHOLD = deadzone\n        if (rightX < -DRIVE_STICK_THRESHOLD || rightX > DRIVE_STICK_THRESHOLD || leftY < -DRIVE_STICK_THRESHOLD || leftY > DRIVE_STICK_THRESHOLD || leftX < -DRIVE_STICK_THRESHOLD || leftX > DRIVE_STICK_THRESHOLD) {\n            //Get stick values and apply modifiers:\n            double drive = -gamepad1.left_stick_y * 1.10;\n            double turn = gamepad1.right_stick_x * 1.25;\n            double strafe = gamepad1.left_stick_x;\n\n            //Calculate each individual motor speed using the stick values:\n            //range.clip calculates a value between min and max, change those values to reduce overall speed\n            frontLeftPower = Range.clip(drive + turn + strafe, -1.0, 1.0);\n            frontRightPower = Range.clip(drive - turn - strafe, -1.0, 1.0);\n            rearLeftPower = Range.clip(drive + turn - strafe, -1.0, 1.0);\n            rearRightPower = Range.clip(drive - turn + strafe, -1.0, 1.0);\n\n            rb.drive(-frontRightPower, -frontLeftPower, -rearRightPower, -rearLeftPower); //Uses each of the motor values calculated above\n\n            telemetry.addData(\"Front-right motor\", \"%5.2f\", frontRightPower);\n            telemetry.addData(\"Back-right motor\", \"%5.2f\", rearRightPower);\n            telemetry.addData(\"Front-left motor\", \"%5.2f\", frontLeftPower);\n            telemetry.addData(\"Back-left motor\", \"%5.2f\", rearLeftPower);\n            telemetry.update();\n        } else {\n            rb.driveStop(); //Stop robot if no stick value (delete this if u want to drift lol)\n        }\n\n    }\n\n    /**\n     * Triggers servo that pushes rings into flywheel\n     */\n    //TODO: Setup teleop for 2 driver control w/ gamepad2\n    //TODO: Configure delay variable in simpleBotConstants.java\n    private void shooter() throws InterruptedException {\n\n        if (gamepad1.right_trigger > TRIGGER_THRESHOLD && !flywheelOn) { //TODO: Figure out why trigger gamepad1.right_trigger > .5f isnt working\n            telemetry.addData(\"WARNING:\", \"flywheel is not running\");\n            telemetry.update();\n\n        } else if (gamepad1.right_trigger > .2) {\n\n            rb.moveShooter(true); //Shoot\n            //TODO:Make screen red to indicate wait\n            Thread.sleep(8); //8ms = time for ring to leave shooter\n            rb.flywheel.setPower(.92); //Increase speed as soon as ring is not in contact with flywheel to increase time back to normal speed\n            Thread.sleep(117);\n            rb.flywheel.setPower(FLYWHEEL_SPEED); //Return to normal speed\n\n            Thread.sleep(67); //Wait a tiny bit before going back (originally 200 but this value is subtracted from prior Thread.sleep statements)\n            rb.moveShooter(false);\n            Thread.sleep(150); //Wait for flywheel to get back to 100 percent speed\n\n        }\n\n    }\n\n    /**\n     * Turns flywheel on and off\n     */\n    private void flywheel() throws InterruptedException {\n\n        if (gamepad1.right_bumper && !flywheelOn) {\n            telemetry.addData(\">\", \"Flywheel ON\");\n            telemetry.update();\n            rb.runFlywheel(true);\n            flywheelOn = true;\n            Thread.sleep(BUTTON_DELAY); //TODO: Make better code than this\n        } else if (gamepad1.right_bumper && flywheelOn) {\n            telemetry.addData(\">\", \"Flywheel OFF\");\n            telemetry.update();\n            rb.runFlywheel(false);\n            flywheelOn = false;\n            Thread.sleep(BUTTON_DELAY);\n        }\n\n\n    }\n\n    /**\n     * Turns intake on and off\n     */\n    private void intake() throws InterruptedException {\n\n        if (gamepad1.left_bumper && !intakeOn) {\n            telemetry.addData(\">\", \"Intake ON\");\n            telemetry.update();\n            rb.runIntake(true, false);\n            intakeOn = true;\n            Thread.sleep(BUTTON_DELAY);\n\n        } else if (gamepad1.left_bumper && intakeOn) {\n            telemetry.addData(\">\", \"Intake OFF\");\n            telemetry.update();\n            rb.runIntake(false, false);\n            intakeOn = false;\n            Thread.sleep(BUTTON_DELAY);\n        }\n    }\n\n    /**\n     * Turns intake on and off\n     */\n    private void intakeEject() throws InterruptedException {\n\n        if (gamepad1.left_stick_button && !intakeOn) {\n            telemetry.addData(\">\", \"Intake EJECT\");\n            telemetry.update();\n            rb.runIntake(true, true);\n            intakeOn = true;\n            intakeIsEjecting = true;\n            Thread.sleep(BUTTON_DELAY);\n\n        } else if (gamepad1.left_stick_button && intakeIsEjecting || gamepad1.left_bumper && intakeIsEjecting) {\n            telemetry.addData(\">\", \"Intake OFF\");\n            telemetry.update();\n            rb.runIntake(false, false);\n            intakeOn = false;\n            Thread.sleep(BUTTON_DELAY);\n        }\n    }\n\n    private void lifter() throws InterruptedException {\n        if (gamepad1.x && lifterUp) {\n\n            telemetry.addData(\">\", \"Lifter DOWN\");\n            telemetry.update();\n            rb.setLifterMotor(false, .25);\n            lifterUp = false;\n            Thread.sleep(BUTTON_DELAY);\n\n        } else if (gamepad1.x) {\n\n            telemetry.addData(\">\", \"Lifter UP\");\n            telemetry.update();\n            rb.setLifterMotor(true, -.75);\n            lifterUp = true;\n            Thread.sleep(BUTTON_DELAY);\n\n        }\n    }\n\n    private void captureAngle() {\n        if (gamepad1.dpad_down) {\n            rb.driveForwardByEncoderAndIMU(200, rb.FL, .25, .10, DEFAULT_ACCELERATION_INCREMENT);\n        }\n    }\n\n    private void rotateToAngle() throws InterruptedException {\n        if (gamepad1.right_stick_button) {\n            telemetry.addData(\"log:\", \"Driving to angle...\");\n            telemetry.update();\n            rb.rotate(SHOOTER_DEFAULT_ROTATION, .4); //-8.6\n            telemetry.addData(\"log:\", \"Done driving to angle!\");\n            telemetry.update();\n\n        }\n    }\n\n    private void powershotSpeed() {\n        if (gamepad1.dpad_down) {\n            if (!powershotSpeedActive) {\n                rb.flywheel.setPower(FLYWHEEL_POWERSHOT_SPEED);\n                powershotSpeedActive = true;\n            } else {\n                rb.flywheel.setPower(FLYWHEEL_SPEED);\n                powershotSpeedActive = false;\n            }\n\n            while (gamepad1.dpad_down && opModeIsActive()) { //wait until button is released to restart listener\n\n            }\n        }\n    }\n\n    private void rapidRotateLeft() {\n        if (gamepad1.dpad_left) {\n            rb.turn(-1);\n\n        }\n    }\n\n    private void rapidRotateRight() {\n        if (gamepad1.dpad_right) {\n\n            rb.turn(1);\n\n\n        }\n    }\n\n\n    private void volkswagenMode() throws InterruptedException {\n        if (gamepad1.dpad_left && gamepad1.share && FLYWHEEL_SPEED != .7) {\n            FLYWHEEL_SPEED = .7;\n            telemetry.addData(\">\", \"..1\");\n            telemetry.update();\n            Thread.sleep(BUTTON_DELAY);\n        } else if (gamepad1.dpad_left && gamepad1.share && FLYWHEEL_SPEED == .7) {\n            FLYWHEEL_SPEED = .77;\n            telemetry.addData(\">\", \"..0\");\n            telemetry.update();\n            Thread.sleep(BUTTON_DELAY);\n        }\n    }\n\n    private void alignToGoal() throws InterruptedException {\n        if (gamepad1.left_trigger > TRIGGER_THRESHOLD) {\n            telemetry.addData(\"STATUS:\", \"Rotating...\");\n            telemetry.update();\n            double readingFromSideSensor = 5; //TODO: Change this with actual code and convert to inches: rangeSensor.getDistance(DistanceUnit.INCH))\n            double sideLength = SIDE_WALL_TO_TOWER_DISTANCE - (SIDE_TO_CENTER_DISTANCE + readingFromSideSensor);\n            //- angle values go to the right and + go to the left\n\n            double frontLength = CENTER_TO_TOWER_DISTANCE;\n\n            double angleToRotate = Math.toDegrees(Math.atan(sideLength / frontLength)) + SHOOTER_DEFAULT_ROTATION;\n\n            rb.rotate(angleToRotate, .6);\n\n            telemetry.addData(\"STATUS:\", \"Done Rotating!!\");\n            telemetry.update();\n            //TODO: Change led color + maybe auto shoot if it works well?\n\n            //1. Calculate distance from center of shooter to side wall\n            //2. Assume approximate constant distance to front wall (or we can use sensors later)\n            //3. do arctan (side wall distance / constant to front wall)\n            //4. using angle from arctan, make rotation positive or negative\n            //5. Subtract shooter offset angle\n            //6. Rotate to angle and set LED status lights\n        }\n    }\n\n\n    /**\n     * Logs IMU data to telemetry\n     */\n    void composeTelemetry() throws InterruptedException {\n\n        // At the beginning of each telemetry update, grab a bunch of data\n        // from the IMU that we will then display in separate lines.\n        telemetry.addAction(new Runnable() {\n            @Override\n            public void run() {\n                // Acquiring the angles is relatively expensive; we don't want\n                // to do that in each of the three items that need that info, as that's\n                // three times the necessary expense.\n                angles = rb.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n//               gravity = rb.imu.getGravity(); dont need gravity?\n            }\n        });\n\n        telemetry.addLine()\n                .addData(\"status\", new Func<String>() {\n                    @Override\n                    public String value() {\n                        return rb.imu.getSystemStatus().toShortString();\n                    }\n                })\n                .addData(\"calib\", new Func<String>() {\n                    @Override\n                    public String value() {\n                        return rb.imu.getCalibrationStatus().toString();\n                    }\n                });\n\n        telemetry.addLine()\n                .addData(\"heading\", new Func<String>() {\n                    @Override\n                    public String value() {\n                        return formatAngle(angles.angleUnit, angles.firstAngle);\n                    }\n                })\n                .addData(\"roll\", new Func<String>() {\n                    @Override\n                    public String value() {\n                        return formatAngle(angles.angleUnit, angles.secondAngle);\n                    }\n                })\n                .addData(\"pitch\", new Func<String>() {\n                    @Override\n                    public String value() {\n                        return formatAngle(angles.angleUnit, angles.thirdAngle);\n                    }\n                });\n\n        Thread.sleep(3000); //throttle display\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Formatting\n    //----------------------------------------------------------------------------------------------\n\n    String formatAngle(AngleUnit angleUnit, double angle) {\n        return formatDegrees(AngleUnit.DEGREES.fromUnit(angleUnit, angle));\n    }\n\n    String formatDegrees(double degrees) {\n        return String.format(Locale.getDefault(), \"%.1f\", AngleUnit.DEGREES.normalize(degrees));\n    }\n\n\n    //Old Functions: Keeping for reference\n\n//\n//    private void platform(){\n//        boolean dpadUp = gamepad2.dpad_up;\n//        boolean dpadDown = gamepad2.dpad_down;\n////        if(rightTrigger>.15){\n////            rb.setPlatformUp(false);\n////        }else if(leftTrigger>.15){\n////            rb.setPlatformUp(true);\n////        }\n//\n//        if(dpadUp){\n//            rb.setPlatformUp(true);\n//        }else if(dpadDown){\n//            rb.setPlatformUp(false);\n//        }\n//    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/simpleBotTeleOp.java	(revision 43a2d64631ed9bab716cd1efb31b9cf993580125)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/simpleBotTeleOp.java	(date 1614094547000)
@@ -182,7 +182,7 @@
             rb.moveShooter(true); //Shoot
             //TODO:Make screen red to indicate wait
             Thread.sleep(8); //8ms = time for ring to leave shooter
-            rb.flywheel.setPower(.92); //Increase speed as soon as ring is not in contact with flywheel to increase time back to normal speed
+            rb.flywheel.setPower(.98); //Increase speed as soon as ring is not in contact with flywheel to increase time back to normal speed
             Thread.sleep(117);
             rb.flywheel.setPower(FLYWHEEL_SPEED); //Return to normal speed
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/simpleBotConstants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.simpleBotCode;\n\n\npublic final class simpleBotConstants {\n\n    //Speeds:\n    public static double FLYWHEEL_SPEED = .77;  //Volkswagen Mode = .7\n    public static double FLYWHEEL_POWERSHOT_SPEED = .68;\n    //.95 = 28.45 ft @ 31 degrees\n    //.53 = 9.4 ft @ 31 degrees\n    //.65 = 13.12ft @ 31 degrees\n    //.73 = 16.60 ft @ 31 degrees\n    //.71 = 16.21 @ 31 degrees\n    public static final double INTAKE_SPEED = 1;\n    public static final double DEFAULT_ACCELERATION_INCREMENT = 0.01;\n\n    //ROTATIONS\n    public static final double SHOOTER_DEFAULT_ROTATION = -8.6; //The angle that the robot needs to be at for the shooter to shoots straight (recorded at FLYWHEEL_SPEED = .77)\n\n    //Controls:\n    public static final float DRIVE_STICK_THRESHOLD = .0f;\n    public static final float DRIVE_STICK_THRESHOLD_SQUARED = DRIVE_STICK_THRESHOLD * DRIVE_STICK_THRESHOLD;\n    public static final float TRIGGER_THRESHOLD = .4f;\n    public static final int BUTTON_DELAY = 250; //Delay after any toggle button is pressed before button is checked again. idk\n\n    //Motor:\n    public static final int LIFTER_MOTOR_UP = 2;\n    public static final int LIFTER_MOTOR_MID = 100;\n    public static final int LIFTER_MOTOR_DOWN = 465;\n\n    //Wheel Diameter = 100m\n    //100m * pi = 314.16mm = circumference = 1 wheel rotation\n    //767.2 Ticks per 314.16mm distance traveled\n    //2 ft (1 tile distance) = 609.6mm\n    //609.6/314.16 = 1.940412528647823\n    //1.940412528647823 * 767.2 ticks = 1488.684491978609626 ticks per tile?\n\n    public static final double TICKS_PER_ROTATION = 767.2;\n    public static final double ENCODER_DRIVE_ONE_TILE = 1.940412528647823 * TICKS_PER_ROTATION; //Evaluates to 1488.684491978609626 right now\n\n\n    //Servo:\n    public static final double SHOOTER_OUT = .41;\n    public static final double SHOOTER_IN = .29;\n    public static final double LIFTER_MAXIMUM = .58;\n    public static final double LIFTER_UP = .61; //.60 before\n    public static final double LIFTER_MID = .79;\n    public static final double LIFTER_DOWN = 1; //.88 before\n    public static final double LIFTER_MINIMUM = .99;\n\n    //Color Sensor:\n    //Setting the correct WHITE_ALPHA_THRESHOLD value is key to stopping correctly. This should be set half way between the light and dark values.\n    public static final double WHITE_ALPHA_THRESHOLD = 170; //TODO: Update Color Values on real field\n\n    //Distance Sensor: (IN INCHES)\n    public static final double SIDE_TO_CENTER_DISTANCE = 7.44; //inches\n    public static final double FRONT_TO_CENTER_DISTANCE = 10.17;\n    public static final double CENTER_TO_TOWER_DISTANCE = FRONT_TO_CENTER_DISTANCE + 61;\n    public static final double SIDE_WALL_TO_TOWER_DISTANCE = 34.5;\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/simpleBotConstants.java	(revision 43a2d64631ed9bab716cd1efb31b9cf993580125)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/simpleBotConstants.java	(date 1614097834000)
@@ -5,7 +5,7 @@
 
     //Speeds:
     public static double FLYWHEEL_SPEED = .77;  //Volkswagen Mode = .7
-    public static double FLYWHEEL_POWERSHOT_SPEED = .68;
+    public static double FLYWHEEL_POWERSHOT_SPEED = .5;
     //.95 = 28.45 ft @ 31 degrees
     //.53 = 9.4 ft @ 31 degrees
     //.65 = 13.12ft @ 31 degrees
