Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/simpleBotTeleOp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.simpleBotCode;\n\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.util.ElapsedTime;\nimport com.qualcomm.robotcore.util.Range;\n\nimport org.firstinspires.ftc.robotcore.external.Func;\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n\nimport java.util.Locale;\n\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.BUTTON_DELAY;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.CENTER_TO_TOWER_DISTANCE;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.DEFAULT_ACCELERATION_INCREMENT;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.DRIVE_STICK_THRESHOLD;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.FLYWHEEL_POWERSHOT_SPEED;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.FLYWHEEL_SPEED;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.LIFTER_MOTOR_MID;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.SHOOTER_DEFAULT_ROTATION;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.SIDE_TO_CENTER_DISTANCE;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.SIDE_WALL_TO_TOWER_DISTANCE;\nimport static org.firstinspires.ftc.teamcode.simpleBotCode.simpleBotConstants.TRIGGER_THRESHOLD;\n\n\n@TeleOp(name = \"!QM TeleOP\", group = \"!Primary\")\npublic class simpleBotTeleOp extends LinearOpMode {\n\n    //private final FtcDashboard dashboard = FtcDashboard.getInstance(); //Comment this out when not using dashboard\n    private final HardwareSimpleBot rb = new HardwareSimpleBot();\n    // Declare OpMode members.\n    private final ElapsedTime runtime = new ElapsedTime();\n\n    //Setup variables:\n    private boolean flywheelOn = false;\n    private final boolean shooterOut = false;\n    private boolean intakeOn = false;\n    private boolean intakeIsEjecting = false;\n    private boolean lifterUp = true; //Default is true because needs to start up to stay in 18in\n    private boolean powershotSpeedActive = false;\n\n\n\n    // State used for updating telemetry\n    Orientation angles;\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        //telemetry = new MultipleTelemetry(telemetry, dashboard.getTelemetry());\n\n        telemetry.addData(\"Status\", \"Initializing\");\n        telemetry.update();\n\n\n        telemetry.addData(\"Status\", \"Initializing Hardware...\");\n        telemetry.update();\n        rb.init(hardwareMap, this); //runs init stuff in HardwareSimpleBot.java\n        rb.lifterMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        telemetry.addData(\"Status\", \"Hardware Map Initialized\");\n        telemetry.update();\n\n        telemetry.addData(\"Status\", \"Calibrating IMU...\");\n        telemetry.update();\n        // make sure the imu gyro is calibrated before continuing.\n        //IMPORTANT: The gyro will not calibrate unless the robot is not moving, make sure the robot is still during initialization.\n        while (!isStopRequested() && !rb.imu.isGyroCalibrated()) {\n            sleep(50);\n            idle();\n        }\n\n        telemetry.addData(\"imu calib status: \", rb.imu.getCalibrationStatus().toString());\n\n        composeTelemetry();\n\n        telemetry.addData(\"Status\", \"Initialized, Ready to Start\");\n        telemetry.update();\n        // Wait for the game to start (driver presses PLAY)\n        rb.lifterMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        waitForStart(); //Everything up to here is initialization\n        runtime.reset();\n\n        // run until the end of the match (driver presses STOP)\n        while (opModeIsActive()) {\n\n            drive(); //Drive robot with sticks\n            shooter(); // Triggers servo that pushes rings into flywheel\n            flywheel(); // Turns flywheel on and off\n            intake();//Turns intake on and off\n            intakeEject(); //Runs intake in reverse for emergencies\n            lifter();//Moves lifter up and down\n            powershotSpeed();\n            //captureAngle(); //TESTING ONLY: Captures angle\n            rotateToAngle(); //TESTING ONLY (for now): Rotates\n            rapidRotateLeft(); //TESTING ONLY: Rotates to the left at max speed\n            rapidRotateRight(); //TESTING ONLY: Rotates to the right at max speed\n            volkswagenMode();\n            alignToGoal();\n\n            telemetry.addData(\"Side Distance in Inches:\", String.valueOf(rb.sensorRangeSide.getDistance(DistanceUnit.INCH)));\n            telemetry.update(); //for imu display\n\n\n            /* CONTROLS (for xbox 360 controller)\n             * Driver: (Start + A)\n             * Left Stick - Movement\n             * Right Stick - Rotation\n             * Left Bumper - Intake\n             * Right Bumper - Flywheel on/off\n             * Right Trigger - Shoot servo (only works if flywheel is on)\n             * Left Trigger - TESTING ONLY: Aligns robot to goal\n             * X - Wobble Goal Lifter\n             * Right Stick Button - Rotate -8.6 degrees to shoot straight\n             * Left Stick Button - Intake Eject for Emergencies\n             * D-Pad Down - Slows down flywheel for powershots\n             * D-Pad Left - Rapid Rotate Left\n             * D-Pad Right - Rapid Rotate Right\n             * D-pad Left + Share Button - Volkswagen Mode (do not use)\n             * Gunner: (Start + B) //TODO: Add gunner controls\n             *\n             * */\n        }\n    }\n\n\n    /**\n     * Main mecanum movement function\n     */\n    private void drive() {\n        //Front of robot is  intake side rn\n        //Init variables\n        double frontLeftPower;\n        double frontRightPower;\n        double rearLeftPower;\n        double rearRightPower;\n\n\n        double leftY = gamepad1.left_stick_y;\n        double leftX = gamepad1.left_stick_x;\n        double rightX = gamepad1.right_stick_x;\n\n//        pattern = RevBlinkinLedDriver.BlinkinPattern.ORANGE;\n//        blinkinLedDriver.setPattern(pattern);\n        //DRIVE_STICK_THRESHOLD = deadzone\n        if (rightX < -DRIVE_STICK_THRESHOLD || rightX > DRIVE_STICK_THRESHOLD || leftY < -DRIVE_STICK_THRESHOLD || leftY > DRIVE_STICK_THRESHOLD || leftX < -DRIVE_STICK_THRESHOLD || leftX > DRIVE_STICK_THRESHOLD) {\n            //Get stick values and apply modifiers:\n            double drive = -gamepad1.left_stick_y * 1.10;\n            double turn = gamepad1.right_stick_x * 1.25;\n            double strafe = gamepad1.left_stick_x;\n\n            //Calculate each individual motor speed using the stick values:\n            //range.clip calculates a value between min and max, change those values to reduce overall speed\n            frontLeftPower = Range.clip(drive + turn + strafe, -1.0, 1.0);\n            frontRightPower = Range.clip(drive - turn - strafe, -1.0, 1.0);\n            rearLeftPower = Range.clip(drive + turn - strafe, -1.0, 1.0);\n            rearRightPower = Range.clip(drive - turn + strafe, -1.0, 1.0);\n\n            rb.drive(-frontRightPower, -frontLeftPower, -rearRightPower, -rearLeftPower); //Uses each of the motor values calculated above\n\n            telemetry.addData(\"Front-right motor\", \"%5.2f\", frontRightPower);\n            telemetry.addData(\"Back-right motor\", \"%5.2f\", rearRightPower);\n            telemetry.addData(\"Front-left motor\", \"%5.2f\", frontLeftPower);\n            telemetry.addData(\"Back-left motor\", \"%5.2f\", rearLeftPower);\n            telemetry.update();\n        } else {\n            rb.driveStop(); //Stop robot if no stick value (delete this if u want to drift lol)\n        }\n\n    }\n\n    /**\n     * Triggers servo that pushes rings into flywheel\n     */\n    //TODO: Setup teleop for 2 driver control w/ gamepad2\n    //TODO: Configure delay variable in simpleBotConstants.java\n    private void shooter() throws InterruptedException {\n\n        if (gamepad1.right_trigger > TRIGGER_THRESHOLD && !flywheelOn) { //TODO: Figure out why trigger gamepad1.right_trigger > .5f isnt working\n            telemetry.addData(\"WARNING:\", \"flywheel is not running\");\n            telemetry.update();\n\n        }\n\n        if (gamepad1.right_trigger > .2) {\n\n            rb.moveShooter(true); //Shoot\n            //TODO:Make screen red to indicate wait\n            if (powershotSpeedActive = false) {\n                Thread.sleep(8); //8ms = time for ring to leave shooter\n                rb.flywheel.setPower(1); //Increase speed as soon as ring is not in contact with flywheel to increase time back to normal speed\n                Thread.sleep(117);\n                rb.flywheel.setPower(FLYWHEEL_SPEED); //Return to normal speed\n            } else {\n                Thread.sleep(117 + 8);\n            }\n            Thread.sleep(67); //Wait a tiny bit before going back (originally 200 but this value is subtracted from prior Thread.sleep statements)\n            rb.moveShooter(false);\n            Thread.sleep(150); //Wait for flywheel to get back to 100 percent speed\n\n        }\n\n    }\n\n    /**\n     * Turns flywheel on and off\n     */\n    private void flywheel() throws InterruptedException {\n\n        if (gamepad1.right_bumper && !flywheelOn) {\n            telemetry.addData(\">\", \"Flywheel ON\");\n            telemetry.update();\n            rb.runFlywheel(true);\n            flywheelOn = true;\n            Thread.sleep(BUTTON_DELAY); //TODO: Make better code than this\n        } else if (gamepad1.right_bumper && flywheelOn) {\n            telemetry.addData(\">\", \"Flywheel OFF\");\n            telemetry.update();\n            rb.runFlywheel(false);\n            flywheelOn = false;\n            Thread.sleep(BUTTON_DELAY);\n        }\n\n\n    }\n\n    /**\n     * Turns intake on and off\n     */\n    private void intake() throws InterruptedException {\n\n        if (gamepad1.left_bumper && !intakeOn) {\n            telemetry.addData(\">\", \"Intake ON\");\n            telemetry.update();\n            rb.runIntake(true, false);\n            intakeOn = true;\n            Thread.sleep(BUTTON_DELAY);\n\n        } else if (gamepad1.left_bumper && intakeOn) {\n            telemetry.addData(\">\", \"Intake OFF\");\n            telemetry.update();\n            rb.runIntake(false, false);\n            intakeOn = false;\n            Thread.sleep(BUTTON_DELAY);\n        }\n    }\n\n    /**\n     * Turns intake on and off\n     */\n    private void intakeEject() throws InterruptedException {\n\n        if (gamepad1.left_stick_button && !intakeOn) {\n            telemetry.addData(\">\", \"Intake EJECT\");\n            telemetry.update();\n            rb.runIntake(true, true);\n            intakeOn = true;\n            intakeIsEjecting = true;\n            Thread.sleep(BUTTON_DELAY);\n\n        } else if (gamepad1.left_stick_button && intakeIsEjecting || gamepad1.left_bumper && intakeIsEjecting) {\n            telemetry.addData(\">\", \"Intake OFF\");\n            telemetry.update();\n            rb.runIntake(false, false);\n            intakeOn = false;\n            Thread.sleep(BUTTON_DELAY);\n        }\n    }\n\n    private void lifter() throws InterruptedException {\n        if (gamepad1.x && lifterUp) {\n\n            telemetry.addData(\">\", \"Lifter DOWN\");\n            telemetry.update();\n            rb.setLifterMotor(false, 1);\n            lifterUp = false;\n            Thread.sleep(BUTTON_DELAY);\n\n        } else if (gamepad1.x) {\n\n            telemetry.addData(\">\", \"Lifter UP\");\n            telemetry.update();\n            rb.setLifterMotor(true, -1);\n            lifterUp = true;\n            Thread.sleep(BUTTON_DELAY);\n\n        }\n\n        if (gamepad1.b && lifterUp) {\n            rb.lifterMotor.setPower(.75);\n            rb.lifterMotor.setTargetPosition(LIFTER_MOTOR_MID);\n            lifterUp = false;\n        } else if (gamepad1.b && !lifterUp) {\n            rb.lifterMotor.setPower(-1);\n            rb.lifterMotor.setTargetPosition(LIFTER_MOTOR_MID);\n            lifterUp = false;\n        }\n\n\n    }\n\n    private void captureAngle() {\n        if (gamepad1.dpad_down) {\n            rb.driveForwardByEncoderAndIMU(200, rb.FL, .25, .10, DEFAULT_ACCELERATION_INCREMENT);\n        }\n    }\n\n    private void rotateToAngle() throws InterruptedException {\n        if (gamepad1.right_stick_button) {\n            telemetry.addData(\"log:\", \"Driving to angle...\");\n            telemetry.update();\n            rb.rotate(SHOOTER_DEFAULT_ROTATION, .4); //-8.6\n            telemetry.addData(\"log:\", \"Done driving to angle!\");\n            telemetry.update();\n\n        }\n    }\n\n    private void powershotSpeed() {\n        if (gamepad1.dpad_down) {\n            if (!powershotSpeedActive) {\n                rb.flywheel.setPower(FLYWHEEL_POWERSHOT_SPEED);\n                powershotSpeedActive = true;\n            } else {\n                rb.flywheel.setPower(FLYWHEEL_SPEED);\n                powershotSpeedActive = false;\n            }\n\n            while (gamepad1.dpad_down && opModeIsActive()) { //wait until button is released to restart listener\n\n            }\n        }\n    }\n\n    private void rapidRotateLeft() {\n        if (gamepad1.dpad_left) {\n            rb.turn(-1);\n\n        }\n    }\n\n    private void rapidRotateRight() {\n        if (gamepad1.dpad_right) {\n\n            rb.turn(1);\n\n\n        }\n    }\n\n\n    private void volkswagenMode() throws InterruptedException {\n        if (gamepad1.dpad_left && gamepad1.share && FLYWHEEL_SPEED != .7) {\n            FLYWHEEL_SPEED = .7;\n            telemetry.addData(\">\", \"..1\");\n            telemetry.update();\n            Thread.sleep(BUTTON_DELAY);\n        } else if (gamepad1.dpad_left && gamepad1.share && FLYWHEEL_SPEED == .7) {\n            FLYWHEEL_SPEED = .77;\n            telemetry.addData(\">\", \"..0\");\n            telemetry.update();\n            Thread.sleep(BUTTON_DELAY);\n        }\n    }\n\n    private void alignToGoal() throws InterruptedException {\n        if (gamepad1.left_trigger > TRIGGER_THRESHOLD) {\n            telemetry.addData(\"STATUS:\", \"Rotating...\");\n            telemetry.update();\n            double readingFromSideSensor = rb.sensorRangeSide.getDistance(DistanceUnit.INCH);\n            double sideLength = SIDE_WALL_TO_TOWER_DISTANCE - (SIDE_TO_CENTER_DISTANCE + readingFromSideSensor);\n            //- angle values go to the right and + go to the left\n\n            double frontLength = CENTER_TO_TOWER_DISTANCE;\n\n            double angleToRotate = -Math.toDegrees(Math.atan(sideLength / frontLength)) + SHOOTER_DEFAULT_ROTATION;\n\n            rb.rotate(angleToRotate, .6);\n\n            telemetry.addData(\"STATUS:\", \"Done Rotating!!\");\n            telemetry.update();\n            //TODO: Change led color + maybe auto shoot if it works well?\n\n            //1. Calculate distance from center of shooter to side wall\n            //2. Assume approximate constant distance to front wall (or we can use sensors later)\n            //3. do arctan (side wall distance / constant to front wall)\n            //4. using angle from arctan, make rotation positive or negative\n            //5. Subtract shooter offset angle\n            //6. Rotate to angle and set LED status lights\n        }\n    }\n\n\n    /**\n     * Logs IMU data to telemetry\n     */\n    void composeTelemetry() throws InterruptedException {\n\n        // At the beginning of each telemetry update, grab a bunch of data\n        // from the IMU that we will then display in separate lines.\n        telemetry.addAction(new Runnable() {\n            @Override\n            public void run() {\n                // Acquiring the angles is relatively expensive; we don't want\n                // to do that in each of the three items that need that info, as that's\n                // three times the necessary expense.\n                angles = rb.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n//               gravity = rb.imu.getGravity(); dont need gravity?\n            }\n        });\n\n        telemetry.addLine()\n                .addData(\"status\", new Func<String>() {\n                    @Override\n                    public String value() {\n                        return rb.imu.getSystemStatus().toShortString();\n                    }\n                })\n                .addData(\"calib\", new Func<String>() {\n                    @Override\n                    public String value() {\n                        return rb.imu.getCalibrationStatus().toString();\n                    }\n                });\n\n        telemetry.addLine()\n                .addData(\"heading\", new Func<String>() {\n                    @Override\n                    public String value() {\n                        return formatAngle(angles.angleUnit, angles.firstAngle);\n                    }\n                })\n                .addData(\"roll\", new Func<String>() {\n                    @Override\n                    public String value() {\n                        return formatAngle(angles.angleUnit, angles.secondAngle);\n                    }\n                })\n                .addData(\"pitch\", new Func<String>() {\n                    @Override\n                    public String value() {\n                        return formatAngle(angles.angleUnit, angles.thirdAngle);\n                    }\n                });\n\n        Thread.sleep(3000); //throttle display\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Formatting\n    //----------------------------------------------------------------------------------------------\n\n    String formatAngle(AngleUnit angleUnit, double angle) {\n        return formatDegrees(AngleUnit.DEGREES.fromUnit(angleUnit, angle));\n    }\n\n    String formatDegrees(double degrees) {\n        return String.format(Locale.getDefault(), \"%.1f\", AngleUnit.DEGREES.normalize(degrees));\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/simpleBotTeleOp.java	(revision f614e0cf37ab5c72c45d3f0b7510caf3b86c560f)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/simpleBotCode/simpleBotTeleOp.java	(date 1614435788000)
@@ -56,7 +56,6 @@
         telemetry.addData("Status", "Initializing");
         telemetry.update();
 
-
         telemetry.addData("Status", "Initializing Hardware...");
         telemetry.update();
         rb.init(hardwareMap, this); //runs init stuff in HardwareSimpleBot.java
@@ -77,7 +76,7 @@
 
         composeTelemetry();
 
-        telemetry.addData("Status", "Initialized, Ready to Start");
+        telemetry.addData("Status", "Initialized, Ready to Start. Make sure lifter is in back position");
         telemetry.update();
         // Wait for the game to start (driver presses PLAY)
         rb.lifterMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
@@ -176,10 +175,9 @@
      * Triggers servo that pushes rings into flywheel
      */
     //TODO: Setup teleop for 2 driver control w/ gamepad2
-    //TODO: Configure delay variable in simpleBotConstants.java
     private void shooter() throws InterruptedException {
 
-        if (gamepad1.right_trigger > TRIGGER_THRESHOLD && !flywheelOn) { //TODO: Figure out why trigger gamepad1.right_trigger > .5f isnt working
+        if (gamepad1.right_trigger > TRIGGER_THRESHOLD && !flywheelOn) {
             telemetry.addData("WARNING:", "flywheel is not running");
             telemetry.update();
 
@@ -188,7 +186,6 @@
         if (gamepad1.right_trigger > .2) {
 
             rb.moveShooter(true); //Shoot
-            //TODO:Make screen red to indicate wait
             if (powershotSpeedActive = false) {
                 Thread.sleep(8); //8ms = time for ring to leave shooter
                 rb.flywheel.setPower(1); //Increase speed as soon as ring is not in contact with flywheel to increase time back to normal speed
@@ -210,13 +207,13 @@
      */
     private void flywheel() throws InterruptedException {
 
-        if (gamepad1.right_bumper && !flywheelOn) {
+        if ((gamepad1.right_bumper || gamepad2.right_bumper) && !flywheelOn) {
             telemetry.addData(">", "Flywheel ON");
             telemetry.update();
             rb.runFlywheel(true);
             flywheelOn = true;
             Thread.sleep(BUTTON_DELAY); //TODO: Make better code than this
-        } else if (gamepad1.right_bumper && flywheelOn) {
+        } else if ((gamepad1.right_bumper || gamepad2.right_bumper) && flywheelOn) {
             telemetry.addData(">", "Flywheel OFF");
             telemetry.update();
             rb.runFlywheel(false);
@@ -232,14 +229,14 @@
      */
     private void intake() throws InterruptedException {
 
-        if (gamepad1.left_bumper && !intakeOn) {
+        if ((gamepad1.left_bumper || gamepad2.left_bumper) && !intakeOn) {
             telemetry.addData(">", "Intake ON");
             telemetry.update();
             rb.runIntake(true, false);
             intakeOn = true;
             Thread.sleep(BUTTON_DELAY);
 
-        } else if (gamepad1.left_bumper && intakeOn) {
+        } else if ((gamepad1.left_bumper || gamepad2.left_bumper) && intakeOn) {
             telemetry.addData(">", "Intake OFF");
             telemetry.update();
             rb.runIntake(false, false);
@@ -251,9 +248,10 @@
     /**
      * Turns intake on and off
      */
+
     private void intakeEject() throws InterruptedException {
 
-        if (gamepad1.left_stick_button && !intakeOn) {
+        if ((gamepad1.left_stick_button || gamepad2.left_stick_button) && !intakeOn) {
             telemetry.addData(">", "Intake EJECT");
             telemetry.update();
             rb.runIntake(true, true);
@@ -261,7 +259,7 @@
             intakeIsEjecting = true;
             Thread.sleep(BUTTON_DELAY);
 
-        } else if (gamepad1.left_stick_button && intakeIsEjecting || gamepad1.left_bumper && intakeIsEjecting) {
+        } else if ((gamepad1.left_stick_button || gamepad2.left_stick_button) && intakeIsEjecting || gamepad1.left_bumper && intakeIsEjecting) {
             telemetry.addData(">", "Intake OFF");
             telemetry.update();
             rb.runIntake(false, false);
@@ -335,17 +333,21 @@
         }
     }
 
-    private void rapidRotateLeft() {
+    private void rapidRotateLeft() throws InterruptedException {
         if (gamepad1.dpad_left) {
-            rb.turn(-1);
-
+            while(gamepad1.dpad_left && opModeIsActive()) {
+                rb.turn(-1);
+            }
+            Thread.sleep(BUTTON_DELAY);
         }
     }
 
-    private void rapidRotateRight() {
+    private void rapidRotateRight() throws InterruptedException {
         if (gamepad1.dpad_right) {
-
-            rb.turn(1);
+            while(gamepad1.dpad_right && opModeIsActive()) {
+                rb.turn(1);
+            }
+            Thread.sleep(BUTTON_DELAY);
 
 
         }
